#!/usr/bin/env python3

#################
# prepare_primers
#
# Description:
# Creates all necessary primer resources for a full V-pipe run, starting from a primer bed file
#
# Authors:
# Matteo Carrara (NEXUS Personalized Health Technologies)
#################

import pandas as pd
import argparse
import sys

def create_primer_tsv(primers, output):
    print("Building the primer TSV file...")
    tsvlines = primers[3] + ',' + primers[6]
    try:
        tsvlines.to_csv(output+".tsv", sep="\n", header=False, index=False)
    except:
        sys.exit("Failed to write the tsv file to disk")
    return 0


def create_primer_fasta(primers, output, ref):
    print("Building the primer FASTA file...")
    if(ref == ""):
        ref=primers[0][0]
    
    primers[1] = primers[1].astype("string")
    primers[2] = primers[2].astype("string")
    falines = ">" + primers[3] + "::" + ref + ":" + primers[1] + "-" + primers[2]
    final = pd.concat( [falines, primers[6]], axis=1).stack().reset_index(1, drop=True).to_frame('C').rename(index='CC{}'.format)
    try:
        final.to_csv(output+".primer.fasta", sep="\n", header=False, index=False)
    except:
        sys.exit("Failed to write the FASTA file to disk")
    return 0


def dedupe_exact(rows):
    """Remove exact duplicate rows, keeping the first occurrence."""
    seen = set()
    out = []
    for r in rows:
        key = tuple(r)              # convert list -> hashable tuple
        if key not in seen:
            seen.add(key)
            out.append(r)
    return out


def create_primer_insert_bed(primers, output, ref, psep, npos, spos):
    print("Building the primer inserts BED file")
    if(ref == ""):
        ref=primers[0][0]
    if(spos < npos):
        sys.exit("Error: the primer side is before the primer number. The sorting procedure depends on the primer numbers coming before")
    print("Creating the inserts BED file. The script assumes that primer number always comes before the primer side, that the side is defined as LEFT or RIGHT and that any other information between name, number and side is static")
    #primers = primers.sort_values(primers.columns[3])
    # We first sort by primer number
    primers = primers.sort_values(
        by=primers.columns[3],
        key=lambda s: pd.to_numeric(s.str.split('_').str[1], errors='coerce'),
        na_position='last'
    )
    finallist = []
    primers_complete = []
    all_primers_num = primers[3].str.split("_").str.get(1)
    for i, row in primers.iterrows():
        # skip empty lines, and headers/comments
        if not row[3] or not row[1] or row[1][0] == '#':
            continue
        pnum = row[3].split("_")[npos]
        if pnum in primers_complete:
            continue
        all_for_pnum = all_primers_num.index[ all_primers_num.eq(str(pnum)) ]
        rows = primers.loc[all_for_pnum]
        left = rows[ rows[3].str.contains('LEFT', na=False) ]
        right = rows[ rows[3].str.contains('RIGHT', na=False) ]
        # after extracting and separating all left and right primers for the specific primer number, we need to go through all pairs to generate the inserts
        this_fragments = []
        for p1, left_row in left.iterrows():
            for p2, rigth_row in right.iterrows():
                fragstart = left[2].values[0]
                fragend = right[1].values[0]
                tmp = row[3].split(psep)[0:npos]
                basename = "_".join(tmp)
                fragname = basename + "_INSERT_" + left_row[3].split(psep)[npos]
                this_fragments.append([ref, fragstart, fragend, fragname, left_row[4], left_row[5] ])
        this_fragments = dedupe_exact(this_fragments)
        if len(this_fragments) == 1:
            this_fragments = this_fragments[0]
        primers_complete.append(pnum)
        finallist.append(this_fragments)

    final = pd.DataFrame(finallist)
    try:
        final.to_csv(output+".insert.bed", sep="\t", header=False, index=False)
    except:
        sys.exit("Failed to write the insert BED file to disk")
    return 0


# Script
if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='fetch the primers positions on the reference',
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('--primerfile', required=True, type=str, help='the file containing the list of primers')
    parser.add_argument('--output', required=True, type=str, help='the name of the output file')
    parser.add_argument('--change_ref', required=False, type=str, default="", help='The string to use as reference, in case the primer file uses a different reference name')
    parser.add_argument('--primer_name_sep', required=False, type=str, default="_", help='The separator used between elements of the primer name')
    parser.add_argument('--primer_number_pos', required=True, type=int, help='Position of element with the primer number in the primer name. 0-based')
    parser.add_argument('--primer_side_pos', required=True, type=int, help='Position of element with the primer side in the primer name. 0-based')

    args = parser.parse_args()

    print("This script assumes the primerfile to be a tab-delimited BED with 7 columns: reference, start, end, name, score, strand, sequence")
    primers = pd.read_csv(args.primerfile, sep='\t', header=None)
    create_primer_tsv(primers, args.output)
    create_primer_fasta(primers, args.output, args.change_ref)
    create_primer_insert_bed(primers, args.output, args.change_ref, args.primer_name_sep, args.primer_number_pos, args.primer_side_pos)
