#!/usr/bin/env python3

#################
# prepare_primers
#
# Description:
# Creates all necessary primer resources for a full V-pipe run, starting from a primer bed file
#
# Authors:
# Matteo Carrara (NEXUS Personalized Health Technologies)
#################

import re
import pandas as pd
import argparse
import sys

def create_primer_tsv(primers, output):
    print("Building the primer TSV file...")
    tsvlines = primers[3] + ',' + primers[6]
    try:
        tsvlines.to_csv(output+".tsv", sep="\n", header=False, index=False)
    except:
        sys.exit("Failed to write the tsv file to disk")
    return 0


def create_primer_fasta(primers, output, ref):
    print("Building the primer FASTA file...")
    if(ref == ""):
        ref=primers[0][0]
    
    primers[1] = primers[1].astype("string")
    primers[2] = primers[2].astype("string")
    falines = ">" + primers[3] + "::" + ref + ":" + primers[1] + "-" + primers[2]
    final = pd.concat( [falines, primers[6]], axis=1).stack().reset_index(1, drop=True).to_frame('C').rename(index='CC{}'.format)
    try:
        final.to_csv(output+".primer.fasta", sep="\n", header=False, index=False)
    except:
        sys.exit("Failed to write the FASTA file to disk")
    return 0


def dedupe_exact(rows):
    """Remove exact duplicate rows, keeping the first occurrence."""
    seen = set()
    out = []
    for r in rows:
        key = tuple(r)              # convert list -> hashable tuple
        if key not in seen:
            seen.add(key)
            out.append(r)
    return out



def create_primer_insert_bed(primers, output, ref, name_regexp):
    nrx = re.compile(name_regexp)
    def rxgroups(s):
        m = nrx.search(s)

        assert m is not None, f"Cannot parse name <{s}> with regexp /{name_regexp}/"
        return (m.groupdict(), m)

    print("Building the primer inserts BED file")
    if(ref == ""):
        ref=primers[0][0]
    # if(spos < npos):
    #     sys.exit("Error: the primer side is before the primer number. The sorting procedure depends on the primer numbers coming before")
    print("Creating the inserts BED file. The script assumes that primer number always comes before the primer side, that the side is defined as LEFT or RIGHT and that any other information between name, number and side is static")
    #primers = primers.sort_values(primers.columns[3])
    # We first sort by primer number
    primers = primers.sort_values(
        by=primers.columns[3],
        key=lambda s: pd.to_numeric(s.str.extract(nrx)["num"], errors='coerce'),
        na_position='last'
    )
    finallist = []
    primers_complete = set()
    all_primers_num = primers[3].str.extract(nrx)["num"]
    for i, row in primers.iterrows():
        # skip empty lines, and headers/comments
        if not row[3] or not row[1] or row[1][0] == '#':
            continue
        mg = rxgroups(row[3])
        pnum = int(mg[0]["num"])
        if pnum in primers_complete:
            continue
        all_for_pnum = all_primers_num.index[ all_primers_num.eq(str(pnum)) ]
        rows = primers.loc[all_for_pnum]
        sides = rows[3].str.extract(nrx)["side"]
        left = rows[ sides == 'LEFT' ]
        right = rows[ sides == 'RIGHT' ]
        # after extracting and separating all left and right primers for the specific primer number, we need to go through all pairs to generate the inserts
        this_fragments = []
        for p1, left_row in left.iterrows():
            for p2, rigth_row in right.iterrows():
                fragstart = left[2].values[0]
                fragend = right[1].values[0]
                basename = row[3][0:mg[1].start()]
                fragname = basename + "INSERT_" + rxgroups(left_row[3])[0]["num"]
                this_fragments.append([ref, fragstart, fragend, fragname, left_row[4], left_row[5] ])
        this_fragments = dedupe_exact(this_fragments)
        if len(this_fragments) == 1:
            this_fragments = this_fragments[0]
        primers_complete.add(pnum)
        finallist.append(this_fragments)

    final = pd.DataFrame(finallist)
    try:
        final.to_csv(output+".insert.bed", sep="\t", header=False, index=False)
    except:
        sys.exit("Failed to write the insert BED file to disk")
    return 0


# Script
if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='fetch the primers positions on the reference',
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('--primerfile', required=True, type=str, help='the file containing the list of primers')
    parser.add_argument('--output', required=True, type=str, help='the name of the output file')
    parser.add_argument('--change_ref', required=False, type=str, default="", help='The string to use as reference, in case the primer file uses a different reference name')
    parser.add_argument('--name_regexp', required=False, type=str, default=r"(?P<num>[0-9]+)[^0-9]+(?P<side>LEFT|RIGHT)", help='The regular expression to parse primers names, searching for named groups "num" and "side"')

    args = parser.parse_args()

    print("This script assumes the primerfile to be a tab-delimited BED with 7 columns: reference, start, end, name, score, strand, sequence")
    primers = pd.read_csv(args.primerfile, sep='\t', header=None)
    create_primer_tsv(primers, args.output)
    create_primer_fasta(primers, args.output, args.change_ref)
    create_primer_insert_bed(primers, args.output, args.change_ref, args.name_regexp)
