#!/usr/bin/env python3

import argparse
import numpy as np

def parse_args():
    """ Set up the parsing of command-line arguments """
    parser = argparse.ArgumentParser(description="Script to extract coverage windows for ShoRAH",
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    requiredNamed = parser.add_argument_group('required named arguments')
    requiredNamed.add_argument("-i", required=True, metavar='tsv', dest='coverage',
                               help="File containing samples as columns and loci as rows")
    requiredNamed.add_argument("-r", required=True, metavar='REF', dest='reference',
                               help="Name of the region/chromosome of interest")
    parser.add_argument("-c", required=False, default=100, metavar='INT', dest='min_coverage',
                        type=int, help="Minimum read depth for reporting variants per locus and sample")
    parser.add_argument("-w", required=False, default=201, metavar='INT', dest='offset',
                        type=int, help="Offset used by ShoRAH to construct overlapping windows")
    parser.add_argument("-N", required=False, default=None, metavar='name1,name2,...', dest="patientIDs",
                        help="Patient/sample identifiers as comma separated strings")
    parser.add_argument("-o", required=False, default="coverage_intervals.tsv", metavar='coverage_intervals.tsv', dest='outfile',
                        help="Output file name")

    return parser.parse_args()


def nonzero_intervals(x, offset, start=None):

    if len(x) == 0:
        return 0
    elif not isinstance(x, np.ndarray):
        x = np.array(x)

    edges, = np.nonzero(np.diff(x == 0))
    intervals = [edges + 1]

    if x[0] != 0:
        intervals.insert(0, [0])
    if x[-1] != 0:
        intervals.append([x.size])
    intervals = np.concatenate(intervals)

    if start is not None:
        intervals += start

    intervals_start = intervals[::2] 
    intervals_end   = intervals[1::2]
    
    # NOTE: ShoRAH adds or subtracts 3 * (window-length / window-shift), in
    #       order to ensure that every locus in the target region is covered by
    #       3 window. By default, window-shift is set to 3, meaning that 
    #       overlapping windows are shifted by window-length / 3. In this 
    #       settings the ofsset is equivalent to the window length

    # Check original intervals are at least the window length
    length = intervals_end - intervals_start

    mask = length < offset
    intervals_start = intervals_start[~mask]
    intervals_end   = intervals_end[~mask]

    # Add offset to starting position.
    intervals_start += offset

    # Subtract offset to ending position.
    intervals_end -= offset

    intervals = np.vstack((intervals_start, intervals_end)).T

    return intervals


args = parse_args()

# Load input file
coverage = np.loadtxt(args.coverage, dtype=int, delimiter='\t', skiprows=1)

loci = coverage[:, 0]
coverage = coverage[:, 1:]
num_samples = coverage.shape[1]


if args.patientIDs is not None:
    patientIDs = args.patientIDs.split(",")
    assert len(patientIDs) == num_samples, 'Number of patient/sample identifiers do not match\
                                            number of columns in input file.'
else:
    patientIDs = np.arange(num_samples)

with open(args.outfile, "wt") as outfile:
    # Identify samples with coverage below threshold and discard those read counts
    for idx in range(num_samples):
        mask = coverage[:, idx] < args.min_coverage
        coverage[mask, idx] = 0
        intervals = nonzero_intervals(coverage[:, idx], args.offset, loci[0])

        outfile.write("{}\t{}\n".format(patientIDs[idx],
                      ','.join("{}:{}-{}".format(args.reference , x[0], x[1]) for x in intervals)))

